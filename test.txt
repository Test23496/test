use std::collections::HashMap;
use std::sync::Mutex;
use std::time::Duration;

// MutationCache is able to take the result of update operations and stores them in an LRU
// that can be used to provide a more current view of a requested object.  It requires interpreting
// resourceVersions for comparisons.
// Implementations must be thread-safe.
// TODO find a way to layer this into an informer/lister
pub trait MutationCache {
    fn get_by_key(&self, key: &str) -> Result<Option<Box<dyn std::any::Any>>, Box<dyn std::error::Error>>;
    fn by_index(&self, index_name: &str, index_key: &str) -> Result<Vec<Box<dyn std::any::Any>>, Box<dyn std::error::Error>>;
    fn mutation(&self, obj: Box<dyn std::any::Any>);
}

// ResourceVersionComparator is able to compare object versions.
pub trait ResourceVersionComparator {
    fn compare_resource_version(&self, lhs: &dyn RuntimeObject, rhs: &dyn RuntimeObject) -> i32;
}

// NewIntegerResourceVersionMutationCache returns a MutationCache that understands how to
// deal with objects that have a resource version that:
//
//   - is an integer
//   - increases when updated
//   - is comparable across the same resource in a namespace
//
// Most backends will have these semantics. Indexer may be nil. ttl controls how long an item
// remains in the mutation cache before it is removed.
//
// If includeAdds is true, objects in the mutation cache will be returned even if they don't exist
// in the underlying store. This is only safe if your use of the cache can handle mutation entries
// remaining in the cache for up to ttl when mutations and deletes occur very closely in time.
pub fn new_integer_resource_version_mutation_cache(
    logger: Logger,
    backing_cache: Box<dyn Store>,
    indexer: Option<Box<dyn Indexer>>,
    ttl: Duration,
    include_adds: bool,
) -> Box<dyn MutationCache> {
    Box::new(MutationCacheImpl {
        backing_cache,
        indexer,
        mutation_cache: LRUExpireCache::new(100),
        comparator: EtcdObjectVersioner {},
        ttl,
        include_adds,
        logger,
        lock: Mutex::new(()),
    })
}

// mutationCache doesn't guarantee that it returns values added via Mutation since they can page out and
// since you can't distinguish between, "didn't observe create" and "was deleted after create",
// if the key is missing from the backing cache, we always return it as missing
struct MutationCacheImpl {
    logger: Logger,
    lock: Mutex<()>,
    backing_cache: Box<dyn Store>,
    indexer: Option<Box<dyn Indexer>>,
    mutation_cache: LRUExpireCache,
    include_adds: bool,
    ttl: Duration,
    comparator: EtcdObjectVersioner,
}

impl MutationCache for MutationCacheImpl {
    // GetByKey is never guaranteed to return back the value set in Mutation.  It could be paged out, it could
    // be older than another copy, the backingCache may be more recent or, you might have written twice into the same key.
    // You get a value that was valid at some snapshot of time and will always return the newer of backingCache and mutationCache.
    fn get_by_key(&self, key: &str) -> Result<Option<Box<dyn std::any::Any>>, Box<dyn std::error::Error>> {
        let _lock = self.lock.lock().unwrap();

        let (obj, exists) = self.backing_cache.get_by_key(key)?;
        
        let obj = if !exists {
            if !self.include_adds {
                // we can't distinguish between, "didn't observe create" and "was deleted after create", so
                // if the key is missing, we always return it as missing
                return Ok(None);
            }
            match self.mutation_cache.get(key) {
                Some(obj) => obj,
                None => return Ok(None),
            }
        } else {
            obj.unwrap()
        };

        if let Some(obj_runtime) = obj.downcast_ref::<dyn RuntimeObject>() {
            Ok(Some(self.newer_object(key, obj_runtime)))
        } else {
            Ok(Some(obj))
        }
    }

    // ByIndex returns the newer objects that match the provided index and indexer key.
    // Will return an error if no indexer was provided.
    fn by_index(&self, name: &str, index_key: &str) -> Result<Vec<Box<dyn std::any::Any>>, Box<dyn std::error::Error>> {
        let _lock = self.lock.lock().unwrap();
        
        let indexer = self.indexer.as_ref()
            .ok_or("no indexer has been provided to the mutation cache")?;
        
        let keys = indexer.index_keys(name, index_key)?;
        let mut items = Vec::new();
        let mut key_set = std::collections::HashSet::new();
        
        for key in &keys {
            key_set.insert(key.clone());
            let (obj, exists) = indexer.get_by_key(key)?;
            if !exists {
                continue;
            }
            let obj = obj.unwrap();
            if let Some(obj_runtime) = obj.downcast_ref::<dyn RuntimeObject>() {
                items.push(self.newer_object(key, obj_runtime));
            } else {
                items.push(obj);
            }
        }

        if self.include_adds {
            let indexers = indexer.get_indexers();
            let index_fn = &indexers[name];
            
            // Keys() is returned oldest to newest, so full traversal does not alter the LRU behavior
            for key in self.mutation_cache.keys() {
                let updated = match self.mutation_cache.get(&key) {
                    Some(obj) => obj,
                    None => continue,
                };
                
                if key_set.contains(&key) {
                    continue;
                }
                
                let elements = match index_fn(updated.as_ref()) {
                    Ok(elems) => elems,
                    Err(err) => {
                        self.logger.v(4).info("Unable to calculate an index entry for mutation cache entry", &[("key", &key), ("err", &err.to_string())]);
                        continue;
                    }
                };
                
                for in_index in elements {
                    if in_index == index_key {
                        items.push(updated);
                        break;
                    }
                }
            }
        }

        Ok(items)
    }

    // Mutation adds a change to the cache that can be returned in GetByKey if it is newer than the backingCache
    // copy.  If you call Mutation twice with the same object on different threads, one will win, but its not defined
    // which one.  This doesn't affect correctness, since the GetByKey guaranteed of "later of these two caches" is
    // preserved, but you may not get the version of the object you want.  The object you get is only guaranteed to
    // "one that was valid at some point in time", not "the one that I want".
    fn mutation(&self, obj: Box<dyn std::any::Any>) {
        let _lock = self.lock.lock().unwrap();

        let key = match deletion_handling_meta_namespace_key_func(obj.as_ref()) {
            Ok(k) => k,
            Err(err) => {
                // this is a "nice to have", so failures shouldn't do anything weird
                handle_error_with_logger(&self.logger, err, "DeletionHandlingMetaNamespaceKeyFunc");
                return;
            }
        };

        if let Some(obj_runtime) = obj.downcast_ref::<dyn RuntimeObject>() {
            if let Some(mutated_obj) = self.mutation_cache.get(&key) {
                if let Some(mutated_obj_runtime) = mutated_obj.downcast_ref::<dyn RuntimeObject>() {
                    if self.comparator.compare_resource_version(obj_runtime, mutated_obj_runtime) < 0 {
                        return;
                    }
                }
            }
        }
        self.mutation_cache.add(key, obj, self.ttl);
    }
}

impl MutationCacheImpl {
    // newerObject checks the mutation cache for a newer object and returns one if found. If the
    // mutated object is older than the backing object, it is removed from the  Must be
    // called while the lock is held.
    fn newer_object(&self, key: &str, backing: &dyn RuntimeObject) -> Box<dyn std::any::Any> {
        let mutated_obj = match self.mutation_cache.get(key) {
            Some(obj) => obj,
            None => return Box::new(backing),
        };
        
        let mutated_obj_runtime = match mutated_obj.downcast_ref::<dyn RuntimeObject>() {
            Some(obj) => obj,
            None => return Box::new(backing),
        };
        
        if self.comparator.compare_resource_version(backing, mutated_obj_runtime) >= 0 {
            self.mutation_cache.remove(key);
            return Box::new(backing);
        }
        mutated_obj
    }
}

// etcdObjectVersioner implements versioning and extracting etcd node information
// for objects that have an embedded ObjectMeta or ListMeta field.
struct EtcdObjectVersioner {}

impl EtcdObjectVersioner {
    // ObjectResourceVersion implements Versioner
    fn object_resource_version(&self, obj: &dyn RuntimeObject) -> Result<u64, Box<dyn std::error::Error>> {
        let accessor = meta_accessor(obj)?;
        let version = accessor.get_resource_version();
        if version.is_empty() {
            return Ok(0);
        }
        Ok(version.parse::<u64>()?)
    }
}

impl ResourceVersionComparator for EtcdObjectVersioner {
    // CompareResourceVersion compares etcd resource versions.  Outside this API they are all strings,
    // but etcd resource versions are special, they're actually ints, so we can easily compare them.
    fn compare_resource_version(&self, lhs: &dyn RuntimeObject, rhs: &dyn RuntimeObject) -> i32 {
        let lhs_version = self.object_resource_version(lhs)
            .unwrap_or_else(|err| {
                // coder error
                panic!("{}", err);
            });
        let rhs_version = self.object_resource_version(rhs)
            .unwrap_or_else(|err| {
                // coder error
                panic!("{}", err);
            });

        if lhs_version == rhs_version {
            return 0;
        }
        if lhs_version < rhs_version {
            return -1;
        }

        1
    }
}

// Placeholder types and functions that would need to be defined elsewhere
pub trait RuntimeObject: std::any::Any {}
pub trait Store {
    fn get_by_key(&self, key: &str) -> Result<(Option<Box<dyn std::any::Any>>, bool), Box<dyn std::error::Error>>;
}
pub trait Indexer: Store {
    fn index_keys(&self, name: &str, index_key: &str) -> Result<Vec<String>, Box<dyn std::error::Error>>;
    fn get_indexers(&self) -> HashMap<String, Box<dyn Fn(&dyn std::any::Any) -> Result<Vec<String>, Box<dyn std::error::Error>>>>;
}
struct LRUExpireCache {}
impl LRUExpireCache {
    fn new(_size: usize) -> Self { Self {} }
    fn get(&self, _key: &str) -> Option<Box<dyn std::any::Any>> { None }
    fn add(&self, _key: String, _obj: Box<dyn std::any::Any>, _ttl: Duration) {}
    fn remove(&self, _key: &str) {}
    fn keys(&self) -> Vec<String> { vec![] }
}
struct Logger {}
impl Logger {
    fn v(&self, _level: i32) -> &Self { self }
    fn info(&self, _msg: &str, _args: &[(&str, &str)]) {}
}
fn deletion_handling_meta_namespace_key_func(_obj: &dyn std::any::Any) -> Result<String, Box<dyn std::error::Error>> { Ok(String::new()) }
fn handle_error_with_logger(_logger: &Logger, _err: Box<dyn std::error::Error>, _msg: &str) {}
fn meta_accessor(_obj: &dyn RuntimeObject) -> Result<Box<dyn MetaAccessor>, Box<dyn std::error::Error>> { unimplemented!() }
trait MetaAccessor {
    fn get_resource_version(&self) -> String;
}
