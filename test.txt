use std::collections::HashMap;
use std::cmp::Ordering;
use md5::{Md5, Digest};

// RepackSubsets takes a slice of EndpointSubset objects, expands it to the full
// representation, and then repacks that into the canonical layout.  This
// ensures that code which operates on these objects can rely on the common
// form for things like comparison.  The result is a newly allocated slice.
fn repack_subsets(subsets: Vec<EndpointSubset>) -> Vec<EndpointSubset> {
    // First map each unique port definition to the sets of hosts that
    // offer it.
    let mut all_addrs: HashMap<AddressKey, EndpointAddress> = HashMap::new();
    let mut port_to_addr_ready_map: HashMap<EndpointPort, AddressSet> = HashMap::new();

    for subset in &subsets {
        if subset.ports.is_empty() {
            // Don't discard endpoints with no ports defined, use a sentinel.
            map_addresses_by_port(
                subset,
                EndpointPort { port: -1, ..Default::default() },
                &mut all_addrs,
                &mut port_to_addr_ready_map,
            );
        } else {
            for port in &subset.ports {
                map_addresses_by_port(
                    subset,
                    port.clone(),
                    &mut all_addrs,
                    &mut port_to_addr_ready_map,
                );
            }
        }
    }

    // Next, map the sets of hosts to the sets of ports they offer.
    // Go does not allow maps or slices as keys to maps, so we have
    // to synthesize an artificial key and do a sort of 2-part
    // associative entity.
    let mut key_to_addr_ready_map: HashMap<String, AddressSet> = HashMap::new();
    let mut addr_ready_map_key_to_ports: HashMap<String, Vec<EndpointPort>> = HashMap::new();

    for (port, addrs) in port_to_addr_ready_map {
        let key = hash_addresses(&addrs);
        key_to_addr_ready_map.insert(key.clone(), addrs);
        
        if port.port > 0 {
            // avoid sentinels
            addr_ready_map_key_to_ports
                .entry(key)
                .or_insert_with(Vec::new)
                .push(port);
        } else {
            // Force it to be present in the map
            addr_ready_map_key_to_ports.entry(key).or_insert_with(Vec::new);
        }
    }

    // Next, build the N-to-M association the API wants.
    let mut final_subsets = Vec::new();
    for (key, ports) in addr_ready_map_key_to_ports {
        let mut ready_addrs = Vec::new();
        let mut not_ready_addrs = Vec::new();

        if let Some(addr_map) = key_to_addr_ready_map.get(&key) {
            for (addr_key, ready) in addr_map {
                if let Some(addr) = all_addrs.get(addr_key) {
                    if *ready {
                        ready_addrs.push(addr.clone());
                    } else {
                        not_ready_addrs.push(addr.clone());
                    }
                }
            }
        }

        final_subsets.push(EndpointSubset {
            addresses: ready_addrs,
            not_ready_addresses: not_ready_addrs,
            ports,
        });
    }

    // Finally, sort it.
    sort_subsets(final_subsets)
}

// The sets of hosts must be de-duped, using IP+UID as the key.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct AddressKey {
    ip: String,
    uid: String,
}

type AddressSet = HashMap<AddressKey, bool>;

// mapAddressesByPort adds all ready and not-ready addresses into a map by a single port.
fn map_addresses_by_port(
    subset: &EndpointSubset,
    port: EndpointPort,
    all_addrs: &mut HashMap<AddressKey, EndpointAddress>,
    port_to_addr_ready_map: &mut HashMap<EndpointPort, AddressSet>,
) {
    for addr in &subset.addresses {
        map_address_by_port(addr, &port, true, all_addrs, port_to_addr_ready_map);
    }
    for addr in &subset.not_ready_addresses {
        map_address_by_port(addr, &port, false, all_addrs, port_to_addr_ready_map);
    }
}

// mapAddressByPort adds one address into a map by port, registering the address with a unique pointer, and preserving
// any existing ready state.
fn map_address_by_port(
    addr: &EndpointAddress,
    port: &EndpointPort,
    ready: bool,
    all_addrs: &mut HashMap<AddressKey, EndpointAddress>,
    port_to_addr_ready_map: &mut HashMap<EndpointPort, AddressSet>,
) -> AddressKey {
    // use addressKey to distinguish between two endpoints that are identical addresses
    // but may have come from different hosts, for attribution. For instance, Mesos
    // assigns pods the node IP, but the pods are distinct.
    let mut key = AddressKey {
        ip: addr.ip.clone(),
        uid: String::new(),
    };
    if let Some(target_ref) = &addr.target_ref {
        key.uid = target_ref.uid.clone();
    }

    // Accumulate the address. The full EndpointAddress structure is preserved for use when
    // we rebuild the subsets so that the final TargetRef has all of the necessary data.
    if !all_addrs.contains_key(&key) {
        // Make a copy so we don't write to the
        // input args of this function.
        all_addrs.insert(key.clone(), addr.clone());
    }

    // Remember that this port maps to this address.
    let addr_set = port_to_addr_ready_map
        .entry(port.clone())
        .or_insert_with(HashMap::new);

    // if we have not yet recorded this port for this address, or if the previous
    // state was ready, write the current ready state. not ready always trumps
    // ready.
    if let Some(&was_ready) = addr_set.get(&key) {
        if was_ready {
            addr_set.insert(key.clone(), ready);
        }
    } else {
        addr_set.insert(key.clone(), ready);
    }

    key
}

#[derive(Debug, Clone)]
struct AddrReady {
    addr_key: AddressKey,
    ready: bool,
}

fn hash_addresses(addrs: &AddressSet) -> String {
    // Flatten the list of addresses into a string so it can be used as a
    // map key.  Unfortunately, DeepHashObject is implemented in terms of
    // spew, and spew does not handle non-primitive map keys well.  So
    // first we collapse it into a slice, sort the slice, then hash that.
    let mut slice: Vec<AddrReady> = addrs
        .iter()
        .map(|(k, &ready)| AddrReady {
            addr_key: k.clone(),
            ready,
        })
        .collect();

    slice.sort_by(|a, b| less_addr_ready(a, b));

    let mut hasher = Md5::new();
    deep_hash_object(&mut hasher, &slice);
    let result = hasher.finalize();
    hex::encode(&result[..])
}

fn less_addr_ready(a: &AddrReady, b: &AddrReady) -> Ordering {
    // ready is not significant to hashing since we can't have duplicate addresses
    less_endpoint_address_key(&a.addr_key, &b.addr_key)
}

// LessEndpointAddress compares IP addresses lexicographically and returns true if first argument is lesser than second
fn less_endpoint_address(a: &EndpointAddress, b: &EndpointAddress) -> Ordering {
    let ip_comparison = a.ip.as_bytes().cmp(b.ip.as_bytes());
    if ip_comparison != Ordering::Equal {
        return ip_comparison;
    }

    match (&a.target_ref, &b.target_ref) {
        (None, None) => Ordering::Equal,
        (None, Some(_)) => Ordering::Less,
        (Some(_), None) => Ordering::Greater,
        (Some(a_ref), Some(b_ref)) => a_ref.uid.cmp(&b_ref.uid),
    }
}

fn less_endpoint_address_key(a: &AddressKey, b: &AddressKey) -> Ordering {
    let ip_comparison = a.ip.as_bytes().cmp(b.ip.as_bytes());
    if ip_comparison != Ordering::Equal {
        return ip_comparison;
    }
    a.uid.cmp(&b.uid)
}

// SortSubsets sorts an array of EndpointSubset objects in place.  For ease of
// use it returns the input slice.
fn sort_subsets(mut subsets: Vec<EndpointSubset>) -> Vec<EndpointSubset> {
    for subset in &mut subsets {
        subset.addresses.sort_by(less_endpoint_address);
        subset.not_ready_addresses.sort_by(less_endpoint_address);
        subset.ports.sort_by(|a, b| {
            let h1 = hash_object_port(a);
            let h2 = hash_object_port(b);
            h1.cmp(&h2)
        });
    }

    subsets.sort_by(|a, b| {
        let h1 = hash_object_subset(a);
        let h2 = hash_object_subset(b);
        h1.cmp(&h2)
    });

    subsets
}

fn hash_object_subset(obj: &EndpointSubset) -> Vec<u8> {
    let mut hasher = Md5::new();
    deep_hash_object(&mut hasher, obj);
    hasher.finalize().to_vec()
}

fn hash_object_port(obj: &EndpointPort) -> Vec<u8> {
    let mut hasher = Md5::new();
    deep_hash_object(&mut hasher, obj);
    hasher.finalize().to_vec()
}

// Placeholder for deep hash function - would need proper implementation
// based on your serialization requirements
fn deep_hash_object<T: std::fmt::Debug>(hasher: &mut Md5, obj: &T) {
    let debug_str = format!("{:?}", obj);
    hasher.update(debug_str.as_bytes());
}

// Helper types that would need to be defined based on your Kubernetes types

#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]
struct EndpointPort {
    port: i32,
    name: String,
    protocol: String,
}

#[derive(Clone, Debug, Default)]
struct EndpointAddress {
    ip: String,
    node_name: Option<String>,
    target_ref: Option<ObjectReference>,
}

#[derive(Clone, Debug)]
struct EndpointSubset {
    addresses: Vec<EndpointAddress>,
    not_ready_addresses: Vec<EndpointAddress>,
    ports: Vec<EndpointPort>,
}

#[derive(Clone, Debug)]
struct ObjectReference {
    uid: String,
}
