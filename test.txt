use std::time::{Duration, Instant};

/// PrefixTransformer holds a transformer interface and the prefix that the transformation is located under.
#[derive(Clone)]
pub struct PrefixTransformer {
    pub prefix: Vec<u8>,
    pub transformer: Arc<dyn Transformer>,
}

pub struct PrefixTransformers {
    transformers: Vec<PrefixTransformer>,
    err: String,
}

impl PrefixTransformers {
    /// NewPrefixTransformers supports the Transformer interface by checking the incoming data against the provided
    /// prefixes in order. The first matching prefix will be used to transform the value (the prefix is stripped
    /// before the Transformer interface is invoked). The first provided transformer will be used when writing to
    /// the store.
    pub fn new(err: Option<String>, transformers: Vec<PrefixTransformer>) -> Self {
        let err = err.unwrap_or_else(|| {
            "the provided value does not match any of the supported transformers".to_string()
        });
        
        Self {
            transformers,
            err,
        }
    }
}

#[async_trait::async_trait]
impl Transformer for PrefixTransformers {
    /// TransformFromStorage finds the first transformer with a prefix matching the provided data and returns
    /// the result of transforming the value. It will always mark any transformation as stale that is not using
    /// the first transformer.
    async fn transform_from_storage(
        &self,
        ctx: Context,
        data: &[u8],
        data_ctx: &DataContext,
    ) -> Result<TransformResult, Box<dyn std::error::Error + Send + Sync>> {
        let start = Instant::now();
        let mut errors = Vec::new();
        let resource = get_resource_from_context(&ctx);

        for (i, transformer) in self.transformers.iter().enumerate() {
            if data.starts_with(&transformer.prefix) {
                let stripped_data = &data[transformer.prefix.len()..];
                let result = transformer.transformer.transform_from_storage(ctx.clone(), stripped_data, data_ctx).await;
                
                // To migrate away from encryption, user can specify an identity transformer higher up
                // (in the config file) than the encryption transformer. In that scenario, the identity transformer needs to
                // identify (during reads from disk) whether the data being read is encrypted or not. If the data is encrypted,
                // it shall throw an error, but that error should not prevent the next subsequent transformer from being tried.
                if transformer.prefix.is_empty() && result.is_err() {
                    continue;
                }

                let prefix_str = if transformer.prefix.is_empty() {
                    "identity"
                } else {
                    std::str::from_utf8(&transformer.prefix).unwrap_or("unknown")
                };
                
                match &result {
                    Ok(transform_result) => {
                        record_transformation(&resource, "from_storage", prefix_str, start.elapsed(), None);
                        
                        // It is valid to have overlapping prefixes when the same encryption provider
                        // is specified multiple times but with different keys (the first provider is
                        // being rotated to and some later provider is being rotated away from).
                        //
                        // Example:
                        //
                        //  {
                        //    "aescbc": {
                        //      "keys": [
                        //        {
                        //          "name": "2",
                        //          "secret": "some key 2"
                        //        }
                        //      ]
                        //    }
                        //  },
                        //  {
                        //    "aescbc": {
                        //      "keys": [
                        //        {
                        //          "name": "1",
                        //          "secret": "some key 1"
                        //        }
                        //      ]
                        //    }
                        //  },
                        //
                        // The transformers for both aescbc configs share the prefix k8s:enc:aescbc:v1:
                        // but a failure in the first one should not prevent a later match from being attempted.
                        // Thus we never short-circuit on a prefix match that results in an error.
                        
                        return Ok(TransformResult {
                            data: transform_result.data.clone(),
                            stale: transform_result.stale || i != 0,
                        });
                    }
                    Err(err) => {
                        record_transformation(&resource, "from_storage", prefix_str, start.elapsed(), Some(err));
                        errors.push(err.to_string());
                        continue;
                    }
                }
            }
        }

        if !errors.is_empty() {
            let aggregate_err = errors.join("; ");
            log_transform_err(&ctx, &aggregate_err, "failed to decrypt data");
            return Err(aggregate_err.into());
        }

        record_transformation(&resource, "from_storage", "unknown", start.elapsed(), Some(&self.err));
        Err(self.err.clone().into())
    }

    /// TransformToStorage uses the first transformer and adds its prefix to the data.
    async fn transform_to_storage(
        &self,
        ctx: Context,
        data: &[u8],
        data_ctx: &DataContext,
    ) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {
        let start = Instant::now();
        let transformer = &self.transformers[0];
        let resource = get_resource_from_context(&ctx);
        
        let result = transformer.transformer.transform_to_storage(ctx.clone(), data, data_ctx).await;
        
        let prefix_str = std::str::from_utf8(&transformer.prefix).unwrap_or("unknown");
        
        match result {
            Ok(encrypted_data) => {
                record_transformation(&resource, "to_storage", prefix_str, start.elapsed(), None);
                
                let mut prefixed_data = Vec::with_capacity(transformer.prefix.len() + encrypted_data.len());
                prefixed_data.extend_from_slice(&transformer.prefix);
                prefixed_data.extend_from_slice(&encrypted_data);
                
                Ok(prefixed_data)
            }
            Err(err) => {
                record_transformation(&resource, "to_storage", prefix_str, start.elapsed(), Some(&err));
                log_transform_err(&ctx, &err.to_string(), "failed to encrypt data");
                Err(err)
            }
        }
    }
}

fn log_transform_err(ctx: &Context, err: &str, message: &str) {
    let request_info = get_request_info_from_context(ctx);
    
    // TODO: implement proper logging with klog equivalent
    // if klog_level_6_enabled() {
    //     klog.InfoSDepth(1, message, "err", err, "group", request_info.api_group, ...);
    //     return;
    // }
    
    eprintln!("ERROR: {} - {}: {:?}", message, err, request_info);
}

fn get_request_info_from_context(ctx: &Context) -> RequestInfo {
    // TODO: implement actual request info extraction from context
    ctx.request_info.clone().unwrap_or_default()
}

fn get_resource_from_context(ctx: &Context) -> String {
    let req_info = get_request_info_from_context(ctx);
    format!("{}.{}", req_info.resource, req_info.api_group)
}

fn record_transformation(
    resource: &str,
    direction: &str,
    transformer_type: &str,
    duration: Duration,
    error: Option<&dyn std::error::Error>,
) {
    // TODO: implement metrics recording
    // This would typically record to Prometheus or similar metrics system
    let _ = (resource, direction, transformer_type, duration, error);
}

#[derive(Clone, Default, Debug)]
pub struct RequestInfo {
    pub api_group: String,
    pub api_version: String,
    pub resource: String,
    pub subresource: String,
    pub verb: String,
    pub namespace: String,
    pub name: String,
}

#[derive(Clone)]
pub struct Context {
    pub request_info: Option<RequestInfo>,
}

impl Context {
    pub fn background() -> Self {
        Self {
            request_info: None,
        }
    }
    
    pub fn with_request_info(request_info: RequestInfo) -> Self {
        Self {
            request_info: Some(request_info),
        }
    }
}

pub struct DataContext {
    // Additional context for data transformation
}

impl DataContext {
    pub fn new() -> Self {
        Self {}
    }
}

impl Default for DataContext {
    fn default() -> Self {
        Self::new()
    }
}

pub struct TransformResult {
    pub data: Vec<u8>,
    pub stale: bool,
}

impl TransformResult {
    pub fn new(data: Vec<u8>, stale: bool) -> Self {
        Self { data, stale }
    }
}

#[async_trait::async_trait]
pub trait Transformer: Send + Sync {
    async fn transform_from_storage(
        &self,
        ctx: Context,
        data: &[u8],
        data_ctx: &DataContext,
    ) -> Result<TransformResult, Box<dyn std::error::Error + Send + Sync>>;

    async fn transform_to_storage(
        &self,
        ctx: Context,
        data: &[u8],
        data_ctx: &DataContext,
    ) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>>;
}

use std::sync::Arc;
========================================================

use std::collections::HashSet;

const MORE_THAN_ONE_ELEMENT_ERR: &str = "more than one provider specified in a single element, should split into different list elements";
const KEY_LEN_ERR_FMT: &str = "secret is not of the expected length, got %d, expected one of %v";
const UNSUPPORTED_SCHEME_ERR_FMT: &str = "unsupported scheme %q for KMS provider, only unix is supported";
const UNSUPPORTED_KMS_API_VERSION_ERR_FMT: &str = "unsupported apiVersion %s for KMS provider, only v1 and v2 are supported";
const AT_LEAST_ONE_REQUIRED_ERR_FMT: &str = "at least one %s is required";
const INVALID_URL_ERR_FMT: &str = "invalid endpoint for kms provider, error: %v";
const MANDATORY_FIELD_ERR_FMT: &str = "%s is a mandatory field for a %s";
const BASE64_ENCODING_ERR: &str = "secrets must be base64 encoded";
const ZERO_OR_NEGATIVE_ERR_FMT: &str = "%s should be a positive value";
const NON_ZERO_ERR_FMT: &str = "%s should be a positive value, or negative to disable";
const ENCRYPTION_CONFIG_NIL_ERR: &str = "EncryptionConfiguration can't be nil";
const INVALID_KMS_CONFIG_NAME_ERR_FMT: &str = "invalid KMS provider name %s, must not contain ':'";
const DUPLICATE_KMS_CONFIG_NAME_ERR_FMT: &str = "duplicate KMS provider name %s, names must be unique";
const EVENTS_GROUP_ERR: &str = "'*.events.k8s.io' objects are stored using the 'events' API group in etcd. Use 'events' instead in the config file";
const EXTENSIONS_GROUP_ERR: &str = "'extensions' group has been removed and cannot be used for encryption";
const STAR_RESOURCE_ERR: &str = "use '*.' to encrypt all the resources from core API group or *.* to encrypt all resources";
const OVERLAP_ERR: &str = "using overlapping resources such as 'secrets' and '*.' in the same resource list is not allowed as they will be masked";
const NON_REST_API_RESOURCE_ERR: &str = "resources which do not have REST API/s cannot be encrypted";
const RESOURCE_NAME_ERR: &str = "resource name should not contain capital letters";
const RESOURCE_ACROSS_GROUP_ERR: &str = "encrypting the same resource across groups is not supported";
const DUPLICATE_RESOURCE_ERR: &str = "the same resource cannot be specified multiple times";

// See https://golang.org/pkg/crypto/aes/#NewCipher for details on supported key sizes for AES.
const AES_KEY_SIZES: &[usize] = &[16, 24, 32];

// See https://godoc.org/golang.org/x/crypto/nacl/secretbox#Open for details on the supported key sizes for Secretbox.
const SECRET_BOX_KEY_SIZES: &[usize] = &[32];

/// ValidateEncryptionConfiguration validates a v1.EncryptionConfiguration.
pub fn validate_encryption_configuration(
    config: Option<&EncryptionConfiguration>,
    reload: bool,
) -> Vec<FieldError> {
    let root = FieldPath::new("resources");
    let mut all_errors = Vec::new();

    let Some(c) = config else {
        all_errors.push(FieldError::required(root.clone(), ENCRYPTION_CONFIG_NIL_ERR));
        return all_errors;
    };

    if c.resources.is_empty() {
        all_errors.push(FieldError::required(
            root.clone(),
            &format!("{}", AT_LEAST_ONE_REQUIRED_ERR_FMT.replace("%s", "resources")),
        ));
        return all_errors;
    }

    // kmsProviderNames is used to track config names to ensure they are unique.
    let mut kms_provider_names = HashSet::new();

    for (i, conf) in c.resources.iter().enumerate() {
        let r = root.index(i).child("resources");
        let p = root.index(i).child("providers");

        if conf.resources.is_empty() {
            all_errors.push(FieldError::required(
                r.clone(),
                &format!("{}", AT_LEAST_ONE_REQUIRED_ERR_FMT.replace("%s", &r.to_string())),
            ));
        }

        all_errors.extend(validate_resource_overlap(&conf.resources, &r));
        all_errors.extend(validate_resource_names(&conf.resources, &r));

        if conf.providers.is_empty() {
            all_errors.push(FieldError::required(
                p.clone(),
                &format!("{}", AT_LEAST_ONE_REQUIRED_ERR_FMT.replace("%s", &p.to_string())),
            ));
        }

        for (j, provider) in conf.providers.iter().enumerate() {
            let path = p.index(j);
            all_errors.extend(validate_single_provider(provider, &path));

            match provider {
                ProviderConfiguration::KMS(kms_config) => {
                    all_errors.extend(validate_kms_configuration(
                        kms_config,
                        &path.child("kms"),
                        &kms_provider_names,
                        reload,
                    ));
                    kms_provider_names.insert(kms_config.name.clone());
                }
                ProviderConfiguration::AESGCM(aes_config) => {
                    all_errors.extend(validate_keys(
                        &aes_config.keys,
                        &path.child("aesgcm").child("keys"),
                        AES_KEY_SIZES,
                    ));
                }
                ProviderConfiguration::AESCBC(aes_config) => {
                    all_errors.extend(validate_keys(
                        &aes_config.keys,
                        &path.child("aescbc").child("keys"),
                        AES_KEY_SIZES,
                    ));
                }
                ProviderConfiguration::Secretbox(secretbox_config) => {
                    all_errors.extend(validate_keys(
                        &secretbox_config.keys,
                        &path.child("secretbox").child("keys"),
                        SECRET_BOX_KEY_SIZES,
                    ));
                }
                ProviderConfiguration::Identity => {}
            }
        }
    }

    all_errors
}

static ANY_GROUP_ANY_RESOURCE: once_cell::sync::Lazy<GroupResource> = once_cell::sync::Lazy::new(|| {
    GroupResource {
        group: "*".to_string(),
        resource: "*".to_string(),
    }
});

fn validate_resource_overlap(resources: &[String], field_path: &FieldPath) -> Vec<FieldError> {
    if resources.len() < 2 {
        // cannot have overlap with a single resource
        return vec![];
    }

    let mut all_errors = Vec::new();

    let r: Vec<GroupResource> = resources
        .iter()
        .map(|resource| parse_group_resource(resource))
        .collect();

    let mut has_overlap = false;
    let mut has_duplicate = false;

    for (i, r1) in r.iter().enumerate() {
        for (j, r2) in r.iter().enumerate() {
            if i == j {
                continue;
            }

            if r1 == r2 && !has_duplicate {
                has_duplicate = true;
                continue;
            }

            if has_overlap {
                continue;
            }

            if r1 == &*ANY_GROUP_ANY_RESOURCE {
                has_overlap = true;
                continue;
            }

            if r1.group != r2.group {
                continue;
            }

            if r1.resource == "*" || r2.resource == "*" {
                has_overlap = true;
                continue;
            }
        }
    }

    if has_duplicate {
        all_errors.push(FieldError::invalid(
            field_path.clone(),
            format!("{:?}", resources),
            DUPLICATE_RESOURCE_ERR,
        ));
    }

    if has_overlap {
        all_errors.push(FieldError::invalid(
            field_path.clone(),
            format!("{:?}", resources),
            OVERLAP_ERR,
        ));
    }

    all_errors
}

fn validate_resource_names(resources: &[String], field_path: &FieldPath) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    for (j, res) in resources.iter().enumerate() {
        let jj = field_path.index(j);

        // check if resource name has capital letters
        if has_capital(res) {
            all_errors.push(FieldError::invalid(
                jj.clone(),
                res.clone(),
                RESOURCE_NAME_ERR,
            ));
            continue;
        }

        // check if resource is '*'
        if res == "*" {
            all_errors.push(FieldError::invalid(
                jj.clone(),
                res.clone(),
                STAR_RESOURCE_ERR,
            ));
            continue;
        }

        // check if resource is:
        // 'apiserveripinfo' OR
        // 'serviceipallocations' OR
        // 'servicenodeportallocations' OR
        if res == "apiserveripinfo"
            || res == "serviceipallocations"
            || res == "servicenodeportallocations"
        {
            all_errors.push(FieldError::invalid(
                jj.clone(),
                res.clone(),
                NON_REST_API_RESOURCE_ERR,
            ));
            continue;
        }

        // check if group is 'events.k8s.io'
        let gr = parse_group_resource(res);
        if gr.group == "events.k8s.io" {
            all_errors.push(FieldError::invalid(
                jj.clone(),
                res.clone(),
                EVENTS_GROUP_ERR,
            ));
            continue;
        }

        // check if group is 'extensions'
        if gr.group == "extensions" {
            all_errors.push(FieldError::invalid(
                jj.clone(),
                res.clone(),
                EXTENSIONS_GROUP_ERR,
            ));
            continue;
        }

        // disallow resource.* as encrypting the same resource across groups does not make sense
        if gr.group == "*" && gr.resource != "*" {
            all_errors.push(FieldError::invalid(
                jj.clone(),
                res.clone(),
                RESOURCE_ACROSS_GROUP_ERR,
            ));
            continue;
        }
    }

    all_errors
}

fn validate_single_provider(
    provider: &ProviderConfiguration,
    field_path: &FieldPath,
) -> Vec<FieldError> {
    let mut all_errors = Vec::new();
    let mut found = 0;

    match provider {
        ProviderConfiguration::KMS(_) => found += 1,
        ProviderConfiguration::AESGCM(_) => found += 1,
        ProviderConfiguration::AESCBC(_) => found += 1,
        ProviderConfiguration::Secretbox(_) => found += 1,
        ProviderConfiguration::Identity => found += 1,
    }

    if found == 0 {
        all_errors.push(FieldError::invalid(
            field_path.clone(),
            format!("{:?}", provider),
            "provider does not contain any of the expected providers: KMS, AESGCM, AESCBC, Secretbox, Identity",
        ));
    }

    if found > 1 {
        all_errors.push(FieldError::invalid(
            field_path.clone(),
            format!("{:?}", provider),
            MORE_THAN_ONE_ELEMENT_ERR,
        ));
    }

    all_errors
}

fn validate_keys(
    keys: &[Key],
    field_path: &FieldPath,
    expected_len: &[usize],
) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    if keys.is_empty() {
        all_errors.push(FieldError::required(
            field_path.clone(),
            &AT_LEAST_ONE_REQUIRED_ERR_FMT.replace("%s", "keys"),
        ));
        return all_errors;
    }

    for (i, key) in keys.iter().enumerate() {
        all_errors.extend(validate_key(key, &field_path.index(i), expected_len));
    }

    all_errors
}

fn validate_key(key: &Key, field_path: &FieldPath, expected_len: &[usize]) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    if key.name.is_empty() {
        all_errors.push(FieldError::required(
            field_path.child("name"),
            &MANDATORY_FIELD_ERR_FMT.replace("%s", "name").replace("%s", "key"),
        ));
    }

    if key.secret.is_empty() {
        all_errors.push(FieldError::required(
            field_path.child("secret"),
            &MANDATORY_FIELD_ERR_FMT.replace("%s", "secret").replace("%s", "key"),
        ));
        return all_errors;
    }

    let secret = match base64::decode(&key.secret) {
        Ok(s) => s,
        Err(_) => {
            all_errors.push(FieldError::invalid(
                field_path.child("secret"),
                "REDACTED".to_string(),
                BASE64_ENCODING_ERR,
            ));
            return all_errors;
        }
    };

    let len_matched = expected_len.iter().any(|&l| secret.len() == l);

    if !len_matched {
        all_errors.push(FieldError::invalid(
            field_path.child("secret"),
            "REDACTED".to_string(),
            &format!(
                "secret is not of the expected length, got {}, expected one of {:?}",
                secret.len(),
                expected_len
            ),
        ));
    }

    all_errors
}

fn validate_kms_configuration(
    config: &KMSConfiguration,
    field_path: &FieldPath,
    kms_provider_names: &HashSet<String>,
    reload: bool,
) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    all_errors.extend(validate_kms_config_name(
        config,
        &field_path.child("name"),
        kms_provider_names,
        reload,
    ));
    all_errors.extend(validate_kms_timeout(config, &field_path.child("timeout")));
    all_errors.extend(validate_kms_endpoint(config, &field_path.child("endpoint")));
    all_errors.extend(validate_kms_cache_size(config, &field_path.child("cachesize")));
    all_errors.extend(validate_kms_api_version(config, &field_path.child("apiVersion")));

    all_errors
}

fn validate_kms_cache_size(config: &KMSConfiguration, field_path: &FieldPath) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    // In defaulting, we set the cache size to the default value only when API version is v1.
    // So, for v2 API version, we expect the cache size field to be nil.
    if config.api_version != "v1" && config.cache_size.is_some() {
        all_errors.push(FieldError::invalid(
            field_path.clone(),
            format!("{:?}", config.cache_size),
            "cachesize is not supported in v2",
        ));
    }

    if config.api_version == "v1" {
        if let Some(cache_size) = config.cache_size {
            if cache_size == 0 {
                all_errors.push(FieldError::invalid(
                    field_path.clone(),
                    cache_size.to_string(),
                    &NON_ZERO_ERR_FMT.replace("%s", "cachesize"),
                ));
            }
        }
    }

    all_errors
}

fn validate_kms_timeout(config: &KMSConfiguration, field_path: &FieldPath) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    if config.timeout <= Duration::ZERO {
        all_errors.push(FieldError::invalid(
            field_path.clone(),
            format!("{:?}", config.timeout),
            &ZERO_OR_NEGATIVE_ERR_FMT.replace("%s", "timeout"),
        ));
    }

    all_errors
}

fn validate_kms_endpoint(config: &KMSConfiguration, field_path: &FieldPath) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    if config.endpoint.is_empty() {
        return vec![FieldError::invalid(
            field_path.clone(),
            "".to_string(),
            &MANDATORY_FIELD_ERR_FMT.replace("%s", "endpoint").replace("%s", "kms"),
        )];
    }

    let u = match url::Url::parse(&config.endpoint) {
        Ok(url) => url,
        Err(err) => {
            return vec![FieldError::invalid(
                field_path.clone(),
                config.endpoint.clone(),
                &INVALID_URL_ERR_FMT.replace("%v", &err.to_string()),
            )];
        }
    };

    if u.scheme() != "unix" {
        return vec![FieldError::invalid(
            field_path.clone(),
            config.endpoint.clone(),
            &UNSUPPORTED_SCHEME_ERR_FMT.replace("%q", u.scheme()),
        )];
    }

    all_errors
}

fn validate_kms_api_version(config: &KMSConfiguration, field_path: &FieldPath) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    if config.api_version != "v1" && config.api_version != "v2" {
        all_errors.push(FieldError::invalid(
            field_path.clone(),
            config.api_version.clone(),
            &UNSUPPORTED_KMS_API_VERSION_ERR_FMT.replace("%s", "apiVersion"),
        ));
    }

    all_errors
}

fn validate_kms_config_name(
    config: &KMSConfiguration,
    field_path: &FieldPath,
    kms_provider_names: &HashSet<String>,
    reload: bool,
) -> Vec<FieldError> {
    let mut all_errors = Vec::new();

    if config.name.is_empty() {
        all_errors.push(FieldError::required(
            field_path.clone(),
            &MANDATORY_FIELD_ERR_FMT.replace("%s", "name").replace("%s", "provider"),
        ));
    }

    // kms v2 providers are not allowed to have a ":" in their name
    if config.api_version != "v1" && config.name.contains(':') {
        all_errors.push(FieldError::invalid(
            field_path.clone(),
            config.name.clone(),
            &INVALID_KMS_CONFIG_NAME_ERR_FMT.replace("%s", &config.name),
        ));
    }

    // kms v2 providers name must always be unique across all kms providers (v1 and v2)
    // kms v1 provider names must be unique across all kms providers (v1 and v2) when hot reloading of encryption configuration is enabled (reload=true)
    if reload || config.api_version != "v1" {
        if kms_provider_names.contains(&config.name) {
            all_errors.push(FieldError::invalid(
                field_path.clone(),
                config.name.clone(),
                &DUPLICATE_KMS_CONFIG_NAME_ERR_FMT.replace("%s", &config.name),
            ));
        }
    }

    all_errors
}

fn has_capital(input: &str) -> bool {
    input != input.to_lowercase()
}

#[derive(Debug, Clone)]
pub struct FieldError {
    pub field: FieldPath,
    pub value: String,
    pub message: String,
    pub error_type: FieldErrorType,
}

#[derive(Debug, Clone)]
pub enum FieldErrorType {
    Required,
    Invalid,
}

impl FieldError {
    pub fn required(field: FieldPath, message: &str) -> Self {
        Self {
            field,
            value: String::new(),
            message: message.to_string(),
            error_type: FieldErrorType::Required,
        }
    }

    pub fn invalid(field: FieldPath, value: String, message: &str) -> Self {
        Self {
            field,
            value,
            message: message.to_string(),
            error_type: FieldErrorType::Invalid,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FieldPath {
    segments: Vec<String>,
}

impl FieldPath {
    pub fn new(root: &str) -> Self {
        Self {
            segments: vec![root.to_string()],
        }
    }

    pub fn child(&self, name: &str) -> Self {
        let mut segments = self.segments.clone();
        segments.push(name.to_string());
        Self { segments }
    }

    pub fn index(&self, i: usize) -> Self {
        let mut segments = self.segments.clone();
        segments.push(format!("[{}]", i));
        Self { segments }
    }
}

impl std::fmt::Display for FieldPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.segments.join("."))
    }
}

use std::time::Duration;
use url;

