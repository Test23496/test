/// validateStructuralCompleteness checks that all value validations in s have
/// a structural counterpart so that every value validation applies to a value
/// with a known schema:
/// - validations for specific properties must have that property (or additionalProperties under an option) structurally defined
/// - additionalProperties validations must have additionalProperties defined in the structural portion of the schema corresponding to that node
/// - Items validations must have also have a corresponding items structurally
///
/// The "structural" portion of the schema refers to all nodes in the
/// schema traversible without following any NestedValueValidations.
fn validate_structural_completeness(
    s: &Option<Structural>,
    fld_path: &FieldPath,
    opts: &ValidationOptions,
) -> FieldErrorList {
    if s.is_none() {
        return FieldErrorList::new();
    }

    let s = s.as_ref().unwrap();
    validate_value_validation_completeness(
        &s.value_validation,
        &Some(s.clone()),
        fld_path,
        fld_path,
        opts,
    )
}

fn validate_value_validation_completeness(
    v: &Option<ValueValidation>,
    s: &Option<Structural>,
    s_path: &FieldPath,
    v_path: &FieldPath,
    opts: &ValidationOptions,
) -> FieldErrorList {
    if v.is_none() {
        return FieldErrorList::new();
    }
    if s.is_none() {
        return vec![FieldError::required(
            s_path,
            &format!("because it is defined in {}", v_path.to_string()),
        )];
    }

    let v = v.as_ref().unwrap();
    let s = s.as_ref().unwrap();
    let mut all_errs = FieldErrorList::new();

    all_errs.extend(validate_nested_value_validation_completeness(
        &v.not,
        &Some(s.clone()),
        s_path,
        &v_path.child("not"),
        opts,
    ));
    for (i, all_of_item) in v.all_of.iter().enumerate() {
        all_errs.extend(validate_nested_value_validation_completeness(
            &Some(all_of_item.clone()),
            &Some(s.clone()),
            s_path,
            &v_path.child("allOf").index(i),
            opts,
        ));
    }
    for (i, any_of_item) in v.any_of.iter().enumerate() {
        all_errs.extend(validate_nested_value_validation_completeness(
            &Some(any_of_item.clone()),
            &Some(s.clone()),
            s_path,
            &v_path.child("anyOf").index(i),
            opts,
        ));
    }
    for (i, one_of_item) in v.one_of.iter().enumerate() {
        all_errs.extend(validate_nested_value_validation_completeness(
            &Some(one_of_item.clone()),
            &Some(s.clone()),
            s_path,
            &v_path.child("oneOf").index(i),
            opts,
        ));
    }

    all_errs
}

fn validate_nested_value_validation_completeness(
    v: &Option<NestedValueValidation>,
    s: &Option<Structural>,
    s_path: &FieldPath,
    v_path: &FieldPath,
    opts: &ValidationOptions,
) -> FieldErrorList {
    if v.is_none() {
        return FieldErrorList::new();
    }
    if s.is_none() {
        return vec![FieldError::required(
            s_path,
            &format!("because it is defined in {}", v_path.to_string()),
        )];
    }

    let v = v.as_ref().unwrap();
    let s = s.as_ref().unwrap();
    let mut all_errs = FieldErrorList::new();

    all_errs.extend(validate_value_validation_completeness(
        &Some(v.value_validation.clone()),
        &Some(s.clone()),
        s_path,
        v_path,
        opts,
    ));
    all_errs.extend(validate_nested_value_validation_completeness(
        &v.items,
        &s.items,
        &s_path.child("items"),
        &v_path.child("items"),
        opts,
    ));

    let s_additional_properties_schema = s
        .additional_properties
        .as_ref()
        .and_then(|ap| ap.structural.clone());

    for (k, v_fld) in &v.properties {
        if let Some(s_fld) = s.properties.get(k) {
            all_errs.extend(validate_nested_value_validation_completeness(
                &Some(v_fld.clone()),
                &Some(s_fld.clone()),
                &s_path.child("properties").key(k),
                &v_path.child("properties").key(k),
                opts,
            ));
        } else {
            if s_additional_properties_schema.is_none()
                || !opts.allow_validation_properties_with_additional_properties
            {
                all_errs.push(FieldError::required(
                    &s_path.child("properties").key(k),
                    &format!(
                        "because it is defined in {}",
                        v_path.child("properties").key(k).to_string()
                    ),
                ));
            } else {
                // Allow validations on specific properties if there exists an
                // additionalProperties structural schema specified instead of
                // direct properties
                // NOTE: This does not allow `additionalProperties: true` structural
                // schema to be combined with specific property validations.
                all_errs.extend(validate_nested_value_validation_completeness(
                    &Some(v_fld.clone()),
                    &s_additional_properties_schema,
                    &s_path.child("additionalProperties"),
                    &v_path.child("properties").key(k),
                    opts,
                ));
            }
        }
    }

    if v.additional_properties.is_some() && opts.allow_nested_additional_properties {
        all_errs.extend(validate_nested_value_validation_completeness(
            &v.additional_properties,
            &s_additional_properties_schema,
            &s_path.child("additionalProperties"),
            &v_path.child("additionalProperties"),
            opts,
        ));
    }

    all_errs
}
